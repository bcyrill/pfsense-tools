diff --git a/sys/net/if_var.h b/sys/net/if_var.h
index 7b5d010..119f0c5 100644
--- a/sys/net/if_var.h
+++ b/sys/net/if_var.h
@@ -207,8 +207,9 @@ struct ifnet {
 	char	if_cspare[3];
 	char	*if_description;	/* interface description */
 	void	*if_pspare[7];		/* 1 netmap, 6 TBD */
-	int	if_ispare[3];
+	int	if_ispare[2];
 	u_int	if_fib;			/* interface FIB */
+	int	if_context;
 };
 
 typedef void if_init_f_t(void *);
diff --git a/sys/netinet/in.h b/sys/netinet/in.h
index 60e0578..ea95f52 100644
--- a/sys/netinet/in.h
+++ b/sys/netinet/in.h
@@ -495,6 +495,13 @@ __END_DECLS
 #define	MCAST_BLOCK_SOURCE		84   /* block a source */
 #define	MCAST_UNBLOCK_SOURCE		85   /* unblock a source */
 
+#define	IP_FW_CTX_ADD			200
+#define	IP_FW_CTX_DEL			201
+#define	IP_FW_CTX_SET			202
+#define	IP_FW_CTX_ADDMEMBER		203
+#define	IP_FW_CTX_DELMEMBER		204
+#define	IP_FW_CTX_GET			205
+
 /*
  * Defaults and limits for options
  */
diff --git a/sys/netinet/ipfw/ip_fw2.c b/sys/netinet/ipfw/ip_fw2.c
index 53cb210..7a35495 100644
--- a/sys/netinet/ipfw/ip_fw2.c
+++ b/sys/netinet/ipfw/ip_fw2.c
@@ -112,6 +112,8 @@ static int default_to_accept = 1;
 static int default_to_accept;
 #endif
 
+VNET_DEFINE(struct ip_fw_chain *, layer3_chain);
+
 VNET_DEFINE(int, autoinc_step);
 
 VNET_DEFINE(unsigned int, fw_tables_max);
@@ -135,8 +137,8 @@ VNET_DEFINE(int, fw_verbose);
 VNET_DEFINE(u_int64_t, norule_counter);
 VNET_DEFINE(int, verbose_limit);
 
-/* layer3_chain contains the list of rules for layer 3 */
-VNET_DEFINE(struct ip_fw_chain, layer3_chain);
+VNET_DEFINE(struct ipfw_context, ipfw_context);
+VNET_DEFINE(struct ip_fw_ctx_list, ip_fw_contexts);
 
 ipfw_nat_t *ipfw_nat_ptr = NULL;
 struct cfg_nat *(*lookup_nat_ptr)(struct nat_list *, int);
@@ -175,9 +177,6 @@ SYSCTL_INT(_net_inet_ip_fw, OID_AUTO, default_to_accept, CTLFLAG_RDTUN,
     "Make the default rule accept all packets.");
 TUNABLE_INT("net.inet.ip.fw.default_to_accept", &default_to_accept);
 TUNABLE_INT("net.inet.ip.fw.tables_max", &default_fw_tables);
-SYSCTL_VNET_INT(_net_inet_ip_fw, OID_AUTO, static_count,
-    CTLFLAG_RD, &VNET_NAME(layer3_chain.n_rules), 0,
-    "Number of static rules");
 
 #ifdef INET6
 SYSCTL_DECL(_net_inet6_ip6);
@@ -839,6 +838,9 @@ ipfw_chk(struct ip_fw_args *args)
 	 */
 	struct ifnet *oif = args->oif;
 
+	if (V_ipfw_context.ctx[oif->if_context] == NULL)
+		return (IP_FW_PASS);
+
 	int f_pos = 0;		/* index of current rule in the array */
 	int retval = 0;
 
@@ -889,7 +891,7 @@ ipfw_chk(struct ip_fw_args *args)
 	 */
 	int dyn_dir = MATCH_UNKNOWN;
 	ipfw_dyn_rule *q = NULL;
-	struct ip_fw_chain *chain = &V_layer3_chain;
+	struct ip_fw_chain *chain = V_ipfw_context.ctx[oif->if_context];
 	struct table_entry *tblent = NULL;
 	struct table_xentry *xtblent = NULL;
 
@@ -2485,8 +2487,21 @@ sysctl_ipfw_table_num(SYSCTL_HANDLER_ARGS)
 	/* Read operation or some error */
 	if ((error != 0) || (req->newptr == NULL))
 		return (error);
+	
+	if (!V_ipfw_vnet_ready)
+		return (0);
 
-	return (ipfw_resize_tables(&V_layer3_chain, ntables));
+	for (int i = 0; i < V_ipfw_context.n_ctx; i++) {
+		if (V_ipfw_context.ctx[i] != NULL) {
+			error = ipfw_resize_tables(V_ipfw_context.ctx[i], ntables);
+			if (error != 0)
+				return (error);
+		}
+	}
+	
+	V_fw_tables_max = ntables;
+	
+	return (0);
 }
 #endif
 /*
@@ -2572,12 +2587,6 @@ ipfw_destroy(void)
 static int
 vnet_ipfw_init(const void *unused)
 {
-	int error;
-	struct ip_fw *rule = NULL;
-	struct ip_fw_chain *chain;
-
-	chain = &V_layer3_chain;
-
 	/* First set up some values that are compile time options */
 	V_autoinc_step = 100;	/* bounded to 1..1000 in add_rule() */
 	V_fw_deny_unknown_exthdrs = 1;
@@ -2587,6 +2596,55 @@ vnet_ipfw_init(const void *unused)
 #ifdef IPFIREWALL_VERBOSE_LIMIT
 	V_verbose_limit = IPFIREWALL_VERBOSE_LIMIT;
 #endif
+
+	/* First set up some values that are compile time options */
+	ipfw_dyn_init();
+
+	/* Context initialization */
+	V_ipfw_context.ctx = malloc(sizeof(struct ip_fw_chain *) * IP_FW_MAXCTX, M_IPFW, M_NOWAIT | M_ZERO);
+	if (V_ipfw_context.ctx == NULL)
+		panic("could not initialize vnet context structures"); /* XXX */
+	
+	V_ipfw_context.n_ctx = 0; /* We start with no context at all */
+	V_ipfw_context.n_ctxid = 1; /* We start with context 1 to simplify code */
+	
+	/* Set initial number of tables */
+	V_fw_tables_max = default_fw_tables;
+	
+	V_ipfw_vnet_ready = 1;		/* Open for business */
+	
+	IPFW_CTX_LOCK_INIT(V_ipfw_context);
+
+	TAILQ_INIT(&V_ip_fw_contexts);
+
+	V_ipfw_context.ifnet_arrival = EVENTHANDLER_REGISTER(ifnet_arrival_event,
+		ipfw_attach_ifnet_event, NULL, EVENTHANDLER_PRI_ANY);
+
+	/*
+	 * Hook the sockopt handler, and the layer2 (V_ip_fw_chk_ptr)
+	 * and pfil hooks for ipv4 and ipv6. Even if the latter two fail
+	 * we still keep the module alive because the sockopt and
+	 * layer2 paths are still useful.
+	 * ipfw[6]_hook return 0 on success, ENOENT on failure,
+	 * so we can ignore the exact return value and just set a flag.
+	 *
+	 * Note that V_fw[6]_enable are manipulated by a SYSCTL_PROC so
+	 * changes in the underlying (per-vnet) variables trigger
+	 * immediate hook()/unhook() calls.
+	 * In layer2 we have the same behaviour, except that V_ether_ipfw
+	 * is checked on each packet because there are no pfil hooks.
+	 */
+	V_ip_fw_ctl_ptr = ipfw_ctl;
+	V_ip_fw_chk_ptr = ipfw_chk;
+	return ipfw_attach_hooks(1);
+}
+
+int
+ipfw_context_init(struct ip_fw_chain *chain)
+{
+	int error;
+	struct ip_fw *rule = NULL;
+
 #ifdef IPFIREWALL_NAT
 	LIST_INIT(&chain->nat);
 #endif
@@ -2598,12 +2656,12 @@ vnet_ipfw_init(const void *unused)
 	if (chain->map)
 		rule = malloc(chain->static_len, M_IPFW, M_WAITOK | M_ZERO);
 
-	/* Set initial number of tables */
-	V_fw_tables_max = default_fw_tables;
+	IPFW_LOCK_INIT(chain);
+
 	error = ipfw_init_tables(chain);
 	if (error) {
 		printf("ipfw2: setting up tables failed\n");
-		free(chain->map, M_IPFW);
+		ipfw_context_uninit(chain);
 		free(rule, M_IPFW);
 		return (ENOSPC);
 	}
@@ -2618,29 +2676,6 @@ vnet_ipfw_init(const void *unused)
 	chain->rules = chain->default_rule = chain->map[0] = rule;
 	chain->id = rule->id = 1;
 
-	IPFW_LOCK_INIT(chain);
-	ipfw_dyn_init();
-
-	/* First set up some values that are compile time options */
-	V_ipfw_vnet_ready = 1;		/* Open for business */
-
-	/*
-	 * Hook the sockopt handler, and the layer2 (V_ip_fw_chk_ptr)
-	 * and pfil hooks for ipv4 and ipv6. Even if the latter two fail
-	 * we still keep the module alive because the sockopt and
-	 * layer2 paths are still useful.
-	 * ipfw[6]_hook return 0 on success, ENOENT on failure,
-	 * so we can ignore the exact return value and just set a flag.
-	 *
-	 * Note that V_fw[6]_enable are manipulated by a SYSCTL_PROC so
-	 * changes in the underlying (per-vnet) variables trigger
-	 * immediate hook()/unhook() calls.
-	 * In layer2 we have the same behaviour, except that V_ether_ipfw
-	 * is checked on each packet because there are no pfil hooks.
-	 */
-	V_ip_fw_ctl_ptr = ipfw_ctl;
-	V_ip_fw_chk_ptr = ipfw_chk;
-	error = ipfw_attach_hooks(1);
 	return (error);
 }
 
@@ -2650,9 +2685,9 @@ vnet_ipfw_init(const void *unused)
 static int
 vnet_ipfw_uninit(const void *unused)
 {
-	struct ip_fw *reap, *rule;
-	struct ip_fw_chain *chain = &V_layer3_chain;
-	int i;
+	struct ifnet *ifp;
+	struct ip_fw_ctx *ctx;
+	struct ip_fw_ctx_iflist *ifl;
 
 	V_ipfw_vnet_ready = 0; /* tell new callers to go away */
 	/*
@@ -2663,17 +2698,52 @@ vnet_ipfw_uninit(const void *unused)
 	(void)ipfw_attach_hooks(0 /* detach */);
 	V_ip_fw_chk_ptr = NULL;
 	V_ip_fw_ctl_ptr = NULL;
-	IPFW_UH_WLOCK(chain);
-	IPFW_UH_WUNLOCK(chain);
-	IPFW_UH_WLOCK(chain);
 
-	IPFW_WLOCK(chain);
 	ipfw_dyn_uninit(0);	/* run the callout_drain */
-	IPFW_WUNLOCK(chain);
 
+	IPFW_CTX_WLOCK(V_ipfw_context);
+	EVENTHANDLER_DEREGISTER(ifnet_arrival_event, V_ipfw_context.ifnet_arrival);
+	if (V_ipfw_context.ctx != NULL) {
+		for (int i = 0; i < IP_FW_MAXCTX; i++)
+			ipfw_context_uninit(V_ipfw_context.ctx[i]);
+		free(V_ipfw_context.ctx, M_IPFW);
+	}
+	IPFW_CTX_WUNLOCK(V_ipfw_context);
+	IPFW_CTX_LOCK_DESTROY(V_ipfw_context);
+
+	while (!TAILQ_EMPTY(&V_ip_fw_contexts)) {
+		ctx = TAILQ_FIRST(&V_ip_fw_contexts);
+		while (!TAILQ_EMPTY(&ctx->iflist)) {
+			ifl = TAILQ_FIRST(&ctx->iflist);
+			TAILQ_REMOVE(&ctx->iflist, ifl, entry);
+			ifp = ifunit(ifl->ifname);
+			if (ifp != NULL) {
+				ifp->if_context = 0; }
+			free(ifl, M_IPFW);
+		}
+		TAILQ_REMOVE(&V_ip_fw_contexts, ctx, entry);
+		free(ctx, M_IPFW);
+	}
+
+	ipfw_dyn_uninit(1);	/* free the remaining parts */
+
+	return (0);
+}
+
+int
+ipfw_context_uninit(struct ip_fw_chain *chain)
+{
+	struct ip_fw *reap, *rule;
+	int i;
+
+	if (chain == NULL)
+		return 0;
+
+	IPFW_UH_WLOCK(chain);
+	IPFW_WLOCK(chain);
+	
 	ipfw_destroy_tables(chain);
 	reap = NULL;
-	IPFW_WLOCK(chain);
 	for (i = 0; i < chain->n_rules; i++) {
 		rule = chain->map[i];
 		rule->x_next = reap;
@@ -2681,12 +2751,16 @@ vnet_ipfw_uninit(const void *unused)
 	}
 	if (chain->map)
 		free(chain->map, M_IPFW);
+	
 	IPFW_WUNLOCK(chain);
 	IPFW_UH_WUNLOCK(chain);
+
 	if (reap != NULL)
 		ipfw_reap_rules(reap);
+	
 	IPFW_LOCK_DESTROY(chain);
-	ipfw_dyn_uninit(1);	/* free the remaining parts */
+	free(chain, M_IPFW);
+
 	return 0;
 }
 
diff --git a/sys/netinet/ipfw/ip_fw_private.h b/sys/netinet/ipfw/ip_fw_private.h
index 95e31d2..8806821 100644
--- a/sys/netinet/ipfw/ip_fw_private.h
+++ b/sys/netinet/ipfw/ip_fw_private.h
@@ -238,7 +238,7 @@ VNET_DECLARE(int, fw_one_pass);
 VNET_DECLARE(int, fw_verbose);
 #define	V_fw_verbose		VNET(fw_verbose)
 
-VNET_DECLARE(struct ip_fw_chain, layer3_chain);
+VNET_DECLARE(struct ip_fw_chain *, layer3_chain);
 #define	V_layer3_chain		VNET(layer3_chain)
 
 VNET_DECLARE(u_int32_t, set_disable);
@@ -272,6 +272,52 @@ struct ip_fw_chain {
 	uint32_t	gencnt;		/* generation count */
 };
 
+struct ip_fw_ctx_iflist {
+	TAILQ_ENTRY(ip_fw_ctx_iflist) entry;
+	char ifname[IFNAMSIZ];
+};
+
+#define	IP_FW_MAXCTX		4096
+#define	IP_FW_CTX_MAXNAME	64
+
+struct ip_fw_ctxmember {
+	char ctxname[IP_FW_CTX_MAXNAME];
+	char ifname[IFNAMSIZ];
+};
+
+struct ip_fw_ctx {
+	TAILQ_ENTRY(ip_fw_ctx) entry;
+	TAILQ_HEAD(, ip_fw_ctx_iflist) iflist;
+	int contextid;
+	char ctxname[IP_FW_CTX_MAXNAME];
+};
+
+TAILQ_HEAD(ip_fw_ctx_list, ip_fw_ctx);
+VNET_DECLARE(struct ip_fw_ctx_list,	ip_fw_contexts);
+#define	V_ip_fw_contexts	VNET(ip_fw_contexts)
+
+struct ipfw_context {
+	struct ip_fw_chain	**ctx; /* Arrays of contextes */
+	int n_ctx;	/* Number of contenxtes */
+	int n_ctxid;	
+	struct rwlock rwctx;
+	eventhandler_tag	ifnet_arrival;
+};
+
+#define	IPFW_CTX_LOCK_INIT(ctx)		rw_init(&(ctx).rwctx, "IPFW context")
+#define	IPFW_CTX_LOCK_DESTROY(ctx)	rw_destroy(&(ctx).rwctx)
+#define	IPFW_CTX_WLOCK(ctx)		rw_wlock(&(ctx).rwctx)
+#define	IPFW_CTX_WUNLOCK(ctx)		rw_wunlock(&(ctx).rwctx)
+#define	IPFW_CTX_RLOCK(ctx)		rw_rlock(&(ctx).rwctx)
+#define	IPFW_CTX_RUNLOCK(ctx)		rw_runlock(&(ctx).rwctx)
+
+VNET_DECLARE(struct ipfw_context, ipfw_context);
+#define	V_ipfw_context		VNET(ipfw_context)
+
+void	ipfw_attach_ifnet_event(void *, struct ifnet *);
+int	ipfw_context_init(struct ip_fw_chain *);
+int	ipfw_context_uninit(struct ip_fw_chain *);
+
 struct sockopt;	/* used by tcp_var.h */
 
 /*
diff --git a/sys/netinet/ipfw/ip_fw_sockopt.c b/sys/netinet/ipfw/ip_fw_sockopt.c
index 72f26c0..2b92aec 100644
--- a/sys/netinet/ipfw/ip_fw_sockopt.c
+++ b/sys/netinet/ipfw/ip_fw_sockopt.c
@@ -938,9 +938,14 @@ ipfw_ctl(struct sockopt *sopt)
 #define	RULE_MAXSIZE	(256*sizeof(u_int32_t))
 	int error;
 	size_t size, len, valsize;
+	struct ifnet *ifp;
 	struct ip_fw *buf, *rule;
 	struct ip_fw_chain *chain;
+	struct ip_fw_ctx *ctx, *tmpctx;
+	struct ip_fw_ctx_iflist *tmpifl, *tmpifl2;
+	struct ip_fw_ctxmember ctxmember;
 	u_int32_t rulenum[2];
+	char ctxname[IP_FW_CTX_MAXNAME];
 	uint32_t opt;
 	char xbuf[128];
 	ip_fw3_opheader *op3 = NULL;
@@ -960,7 +965,210 @@ ipfw_ctl(struct sockopt *sopt)
 			return (error);
 	}
 
-	chain = &V_layer3_chain;
+	switch (sopt->sopt_name) {
+	case IP_FW_CTX_ADD:
+
+		bzero(ctxname, sizeof ctxname);
+                error = sooptcopyin(sopt, ctxname, sizeof ctxname,
+                        sizeof(char));
+		if (error)
+			return (error);
+		
+		ctx = malloc(sizeof(*ctx), M_IPFW, M_WAITOK | M_ZERO);
+		chain = malloc(sizeof(struct ip_fw_chain), M_IPFW, M_WAITOK | M_ZERO);
+		TAILQ_INIT(&ctx->iflist);
+		strlcpy(ctx->ctxname, ctxname, sizeof(ctx->ctxname));
+		IPFW_CTX_WLOCK(V_ipfw_context);
+		TAILQ_FOREACH(tmpctx, &V_ip_fw_contexts, entry) {
+			if (!strcmp(tmpctx->ctxname, ctxname))
+				break;
+		}
+		if (tmpctx != NULL) {
+			free(ctx, M_IPFW);
+			free(chain, M_IPFW);
+			IPFW_CTX_WUNLOCK(V_ipfw_context);
+			return (EEXIST);
+		}
+		++V_ipfw_context.n_ctx;
+		ctx->contextid = V_ipfw_context.n_ctxid++;
+		V_ipfw_context.ctx[ctx->contextid] = chain;
+		ipfw_context_init(V_ipfw_context.ctx[ctx->contextid]); /* XXX: error checking */
+		TAILQ_INSERT_TAIL(&V_ip_fw_contexts, ctx, entry);
+		if (V_ipfw_context.ctx[V_ipfw_context.n_ctxid] != NULL) {
+			for (int i = V_ipfw_context.n_ctxid; i < IP_FW_MAXCTX; i++) {
+				if (V_ipfw_context.ctx[i] == NULL) {
+					V_ipfw_context.n_ctxid = i;
+					break;
+				}
+			}
+		}
+		IPFW_CTX_WUNLOCK(V_ipfw_context);
+		return (0);
+		break;
+	case IP_FW_CTX_DEL:
+
+		bzero(ctxname, sizeof ctxname);
+                error = sooptcopyin(sopt, ctxname, sizeof ctxname,
+                        sizeof(char));
+		if (error)
+			return (error);
+		IPFW_CTX_WLOCK(V_ipfw_context);
+		TAILQ_FOREACH(tmpctx, &V_ip_fw_contexts, entry) {
+			if (!strcmp(tmpctx->ctxname, ctxname))
+				break;
+		}
+		if (tmpctx != NULL) {
+			TAILQ_REMOVE(&V_ip_fw_contexts, tmpctx, entry);
+			if (V_ipfw_context.ctx[tmpctx->contextid] != NULL) {
+				if (V_layer3_chain == V_ipfw_context.ctx[tmpctx->contextid])
+					V_layer3_chain = NULL;
+				ipfw_context_uninit(V_ipfw_context.ctx[tmpctx->contextid]);
+				V_ipfw_context.ctx[tmpctx->contextid] = NULL;
+			}
+			if (V_ipfw_context.n_ctxid > tmpctx->contextid)
+				V_ipfw_context.n_ctxid = tmpctx->contextid;
+			--V_ipfw_context.n_ctx;
+			free(tmpctx, M_IPFW);
+			error = 0;
+		} else 
+			error = EINVAL;
+		IPFW_CTX_WUNLOCK(V_ipfw_context);
+		return (error);
+		break;
+	case IP_FW_CTX_GET:
+		{
+                        int len = 0, want;
+			char *bufout, *tmpbuf;
+
+                	IPFW_CTX_RLOCK(V_ipfw_context);
+			TAILQ_FOREACH(tmpctx, &V_ip_fw_contexts, entry) {
+				len += strlen(tmpctx->ctxname) + 2;
+				TAILQ_FOREACH(tmpifl, &tmpctx->iflist, entry) {
+					len += strlen(tmpifl->ifname) + 1;
+				}
+				len++; // newline
+			}
+                	IPFW_CTX_RUNLOCK(V_ipfw_context);
+
+                        if (len >= sopt->sopt_valsize)
+                                break;
+                        bufout = malloc(len, M_TEMP, M_WAITOK | M_ZERO);
+                        if (bufout == NULL)
+                                break;
+			
+                	IPFW_CTX_RLOCK(V_ipfw_context);
+			want = 0;
+			tmpbuf = bufout;
+			TAILQ_FOREACH(tmpctx, &V_ip_fw_contexts, entry) {
+				want = strlen(tmpctx->ctxname) + 2;
+				sprintf(tmpbuf, "%s: ", tmpctx->ctxname);
+				tmpbuf += want;
+				TAILQ_FOREACH(tmpifl, &tmpctx->iflist, entry) {
+					sprintf(tmpbuf, "%s,", tmpifl->ifname);
+					want = strlen(tmpifl->ifname) + 1;
+					tmpbuf += want;
+				}
+				sprintf(tmpbuf, "\n");
+				tmpbuf++;
+			}
+                	IPFW_CTX_RUNLOCK(V_ipfw_context);
+
+			error = sooptcopyout(sopt, bufout, len);
+                        free(bufout, M_TEMP);
+		}
+		return (error);
+		break;
+	case IP_FW_CTX_SET:
+
+		bzero(ctxname, sizeof ctxname);
+                error = sooptcopyin(sopt, ctxname, sizeof ctxname,
+                        sizeof(char));
+		if (error)
+			return (error);
+
+		IPFW_CTX_RLOCK(V_ipfw_context);
+		TAILQ_FOREACH(tmpctx, &V_ip_fw_contexts, entry) {
+			if (!strcmp(tmpctx->ctxname, ctxname))
+				break;
+		}
+		if (tmpctx != NULL) {
+			V_layer3_chain = V_ipfw_context.ctx[tmpctx->contextid];
+			error = 0;
+		} else
+			error = EINVAL;
+		IPFW_CTX_RUNLOCK(V_ipfw_context);
+		return (error);
+		break;
+	case IP_FW_CTX_ADDMEMBER:
+                error = sooptcopyin(sopt, &ctxmember, sizeof ctxmember, sizeof(ctxmember));
+		if (error)
+			return (error);
+		ifp = ifunit(ctxmember.ifname);
+		if (ifp == NULL)
+			return (ENOENT);
+		tmpifl = malloc(sizeof(*tmpifl), M_IPFW, M_WAITOK | M_ZERO);
+		IPFW_CTX_WLOCK(V_ipfw_context);
+		TAILQ_FOREACH(tmpctx, &V_ip_fw_contexts, entry) {
+			if (!strcmp(tmpctx->ctxname, ctxmember.ctxname))
+				break;
+		}
+		if (tmpctx != NULL) {
+			TAILQ_FOREACH(tmpifl2, &tmpctx->iflist, entry) {
+				if (strlen(tmpifl2->ifname) != strlen(ctxmember.ifname))
+					continue;
+				if (!strcmp(tmpifl2->ifname, ctxmember.ifname))
+					break;
+			}
+			if (tmpifl2 != NULL) {
+				free(tmpifl, M_IPFW);
+				IPFW_CTX_WUNLOCK(V_ipfw_context);
+				return (EEXIST);
+			}
+
+			strlcpy(tmpifl->ifname, ctxmember.ifname, sizeof(tmpifl->ifname));
+			TAILQ_INSERT_HEAD(&tmpctx->iflist, tmpifl, entry);
+			ifp->if_context = tmpctx->contextid;
+		} else
+			free(tmpifl, M_IPFW);
+		IPFW_CTX_WUNLOCK(V_ipfw_context);
+		return (error);
+		break;
+	case IP_FW_CTX_DELMEMBER:
+                error = sooptcopyin(sopt, &ctxmember, sizeof ctxmember, sizeof(ctxmember));
+		if (error)
+			return (error);
+		IPFW_CTX_WLOCK(V_ipfw_context);
+		TAILQ_FOREACH(tmpctx, &V_ip_fw_contexts, entry) {
+			if (!strcmp(tmpctx->ctxname, ctxmember.ctxname))
+				break;
+		}
+		if (tmpctx != NULL) {
+			TAILQ_FOREACH(tmpifl2, &tmpctx->iflist, entry) {
+				if (strlen(tmpifl2->ifname) != strlen(ctxmember.ifname))
+					continue;
+				if (!strcmp(tmpifl2->ifname, ctxmember.ifname)) 
+					break;
+			}
+			if (tmpifl2 == NULL) {
+				IPFW_CTX_WUNLOCK(V_ipfw_context);
+				return (ENOENT);
+			}
+
+			ifp = ifunit(ctxmember.ifname);
+			if (ifp != NULL) {
+				ifp->if_context = 0; }
+			TAILQ_REMOVE(&tmpctx->iflist, tmpifl2, entry);
+			free(tmpifl2, M_IPFW);
+		}
+		IPFW_CTX_WUNLOCK(V_ipfw_context);
+		return (error);
+		break;
+	}
+
+	if (V_layer3_chain == NULL)
+		return (ENOENT);
+
+	chain = V_layer3_chain;
 	error = 0;
 
 	/* Save original valsize before it is altered via sooptcopyin() */
@@ -1432,6 +1640,36 @@ ipfw_ctl(struct sockopt *sopt)
 #undef RULE_MAXSIZE
 }
 
+void
+ipfw_attach_ifnet_event(void *arg __unused, struct ifnet *ifp)
+{
+	struct ip_fw_ctx *tmpctx;
+	struct ip_fw_ctx_iflist *tmpifl;
+	int found;
+
+	CURVNET_SET(ifp->if_vnet);
+
+	found = 0;
+	IPFW_CTX_RLOCK(V_ipfw_context);
+	TAILQ_FOREACH(tmpctx, &V_ip_fw_contexts, entry) {
+		TAILQ_FOREACH(tmpifl, &tmpctx->iflist, entry) {
+			if (strlen(tmpifl->ifname) != strlen(ifp->if_xname))
+				continue;
+			if (!strcmp(tmpifl->ifname, ifp->if_xname)) {
+				printf("Restoring context for interface %s to %d(%s)\n", ifp->if_xname, tmpctx->contextid, tmpctx->ctxname);
+				ifp->if_context = tmpctx->contextid;
+				found = 1;
+				break;
+			}
+		}
+		if (found) {
+			break;
+		}
+	}
+	IPFW_CTX_RUNLOCK(V_ipfw_context);
+
+	CURVNET_RESTORE();
+}
 
 #define	RULE_MAXSIZE	(256*sizeof(u_int32_t))
 
diff --git a/sys/netinet/ipfw/ip_fw_table.c b/sys/netinet/ipfw/ip_fw_table.c
index d388d49..da63cc1 100644
--- a/sys/netinet/ipfw/ip_fw_table.c
+++ b/sys/netinet/ipfw/ip_fw_table.c
@@ -495,7 +495,8 @@ ipfw_resize_tables(struct ip_fw_chain *ch, unsigned int ntables)
 
 	IPFW_WLOCK(ch);
 
-	tbl = (ntables >= V_fw_tables_max) ? V_fw_tables_max : ntables;
+	ntables_old = V_fw_tables_max;
+	tbl = (ntables >= ntables_old) ? ntables_old : ntables;
 
 	/* Copy old table pointers */
 	memcpy(tables, ch->tables, sizeof(void *) * tbl);
@@ -510,9 +511,6 @@ ipfw_resize_tables(struct ip_fw_chain *ch, unsigned int ntables)
 	ch->xtables = xtables;
 	ch->tabletype = tabletype;
 
-	ntables_old = V_fw_tables_max;
-	V_fw_tables_max = ntables;
-
 	IPFW_WUNLOCK(ch);
 
 	/* Check if we need to destroy radix trees */
diff --git a/sys/netinet/raw_ip.c b/sys/netinet/raw_ip.c
index 560cff3..85c2cfc 100644
--- a/sys/netinet/raw_ip.c
+++ b/sys/netinet/raw_ip.c
@@ -556,6 +556,7 @@ rip_ctloutput(struct socket *so, struct sockopt *sopt)
 		case IP_FW3:	/* generic ipfw v.3 functions */
 		case IP_FW_ADD:	/* ADD actually returns the body... */
 		case IP_FW_GET:
+		case IP_FW_CTX_GET:
 		case IP_FW_TABLE_GETSIZE:
 		case IP_FW_TABLE_LIST:
 		case IP_FW_TABLE_GET_ENTRY:
@@ -625,6 +626,11 @@ rip_ctloutput(struct socket *so, struct sockopt *sopt)
 		case IP_FW_TABLE_FLUSH:
 		case IP_FW_NAT_CFG:
 		case IP_FW_NAT_DEL:
+		case IP_FW_CTX_ADD:
+		case IP_FW_CTX_DEL:
+		case IP_FW_CTX_SET:
+		case IP_FW_CTX_ADDMEMBER:
+		case IP_FW_CTX_DELMEMBER:
 			if (V_ip_fw_ctl_ptr != NULL)
 				error = V_ip_fw_ctl_ptr(sopt);
 			else
