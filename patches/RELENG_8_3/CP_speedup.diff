diff --git a/sbin/ipfw/ipfw2.c b/sbin/ipfw/ipfw2.c
index 518c702..de327df 100644
--- a/sbin/ipfw/ipfw2.c
+++ b/sbin/ipfw/ipfw2.c
@@ -381,6 +381,8 @@ do_cmd(int optname, void *optval, uintptr_t optlen)
 
 	if (optname == IP_FW_GET || optname == IP_DUMMYNET_GET ||
 	    optname == IP_FW_ADD || optname == IP_FW3 ||
+	    optname == IP_FW_TABLE_LIST || 
+	    optname == IP_FW_TABLE_GETSIZE ||
 	    optname == IP_FW_NAT_GET_CONFIG ||
 	    optname < 0 ||
 	    optname == IP_FW_NAT_GET_LOG) {
@@ -3821,6 +3823,7 @@ ipfw_flush(int force)
 
 
 static void table_list(uint16_t num, int need_header);
+static void table_list_entry(ipfw_table_xentry *xent);
 
 /*
  * This one handles all table-related commands
@@ -3834,6 +3837,7 @@ ipfw_table_handler(int ac, char *av[])
 {
 	ipfw_table_xentry xent;
 	int do_add;
+	int do_clear;
 	int is_all;
 	size_t len;
 	char *p;
@@ -3932,6 +3936,12 @@ ipfw_table_handler(int ac, char *av[])
 		xent.len = offsetof(ipfw_table_xentry, k) + addrlen;
 
 		ac--; av++;
+		xent.mac_addr = 0;
+		if (do_add && ac >= 2 && strcmp(*av, "mac") == 0) {
+			uint8_t mask[8];
+			get_mac_addr_mask(av[1], (uint8_t*)&xent.mac_addr, mask);
+			ac-=2; av+=2;
+		}
 		if (do_add && ac) {
 			unsigned int tval;
 			/* isdigit is a bit of a hack here.. */
@@ -3974,17 +3984,130 @@ ipfw_table_handler(int ac, char *av[])
 		do {
 			table_list(xent.tbl, is_all);
 		} while (++xent.tbl < a);
+	} else if (_substrcmp(*av, "entrystats") == 0 ||
+		_substrcmp(*av, "entryzerostats") == 0) {
+		do_clear = av[0][5] == 'z';
+		
+		ac--; av++;
+		if (!ac)
+			errx(EX_USAGE, "address required");
+		
+		type = 0;
+		if (ishexnumber(*av[0])) {
+			/* Remove / if exists */
+			if ((p = strchr(*av, '/')) != NULL) {
+				*p = '\0';
+				mask = atoi(p + 1);
+			}
+
+			if (inet_pton(AF_INET, *av, &xent.k.addr6) == 1) {
+				type = IPFW_TABLE_CIDR;
+				if ((p != NULL) && (mask > 32))
+					errx(EX_DATAERR, "bad IPv4 mask width: %s", p + 1);
+				xent.masklen = p ? mask : 32;
+				addrlen = sizeof(struct in_addr);
+			} else if (inet_pton(AF_INET6, *av, &xent.k.addr6) == 1) {
+				type = IPFW_TABLE_CIDR;
+				if ((p != NULL) && (mask > 128))
+					errx(EX_DATAERR, "bad IPv6 mask width: %s", p + 1);
+				xent.masklen = p ? mask : 128;
+				addrlen = sizeof(struct in6_addr);
+			}
+		}
+
+		if ((type == 0) && (strchr(*av, '.') == NULL)) {
+			/* Assume interface name. Copy significant data only */
+			mask = MIN(strlen(*av), IF_NAMESIZE - 1);
+			memcpy(xent.k.iface, *av, mask);
+			/* Set mask to exact match */
+			xent.masklen = 8 * IF_NAMESIZE;
+			type = IPFW_TABLE_INTERFACE;
+			addrlen = IF_NAMESIZE;
+		}
+
+		if (type == 0) {
+			if (lookup_host(*av, (struct in_addr *)&xent.k.addr6) != 0)
+				errx(EX_NOHOST, "hostname ``%s'' unknown", *av);
+			xent.masklen = 32;
+			type = IPFW_TABLE_CIDR;
+			addrlen = sizeof(struct in_addr);
+		}
+		
+		xent.type = type;
+		xent.len = offsetof(ipfw_table_xentry, k) + addrlen;
+		
+		ac--; av++;
+		xent.value = 0;
+		
+		if (do_clear) {
+			if (do_setcmd3(IP_FW_TABLE_XZERO_ENTRY_STATS, &xent, xent.len) < 0) {
+				err(EX_OSERR, "setsockopt(IP_FW_TABLE_XZERO_ENTRY_STATS)");
+			}
+		} else {
+			table_list_entry(&xent);
+		}
 	} else
 		errx(EX_USAGE, "invalid table command %s", *av);
 }
 
 static void
+table_list_entry(ipfw_table_xentry *xent)
+{
+	ipfw_table_xentry *tmp;
+	socklen_t l;
+	char tbuf[128];
+	ip_fw3_opheader *op3;
+	size_t len;
+	
+	/* Prepend value with IP_FW3 header */
+	l = sizeof(ip_fw3_opheader) + sizeof(ipfw_table_xentry);
+	op3 = alloca(l);
+	/* Zero reserved fields */
+	memset(op3, 0, sizeof(ip_fw3_opheader));
+	tmp = (ipfw_table_xentry *)(op3 + 1);
+	memcpy(tmp, xent, sizeof(ipfw_table_xentry));
+	op3->opcode = IP_FW_TABLE_XGET_ENTRY;
+	if (do_cmd(IP_FW3, op3, (uintptr_t)&l) < 0)
+		err(EX_OSERR, "getsockopt(IP_FW_TABLE_XGET_ENTRY)");
+	
+	len = tmp->len - offsetof(ipfw_table_xentry, k);
+	
+	switch (tmp->type) {
+		case IPFW_TABLE_CIDR:
+			if (len == sizeof(in_addr_t)) {
+				/* IPv4 address */
+				inet_ntop(AF_INET, (in_addr_t *)&tmp->k, tbuf, sizeof(tbuf));
+			} else if (len == sizeof(struct in6_addr)) {
+				/* IPv6 address */
+				inet_ntop(AF_INET6, &tmp->k.addr6, tbuf, sizeof(tbuf));
+			} else {
+				/* Unknown CIDR type */
+				return;
+			}
+			
+			printf("%s/%u %u %llu %llu %u\n", tbuf, tmp->masklen, tmp->value, 
+				align_uint64(&tmp->packets), align_uint64(&tmp->bytes), tmp->timestamp);
+			break;
+		
+		case IPFW_TABLE_INTERFACE:
+			printf("%s %u %llu %llu %u\n", tmp->k.iface, tmp->value, 
+				align_uint64(&tmp->packets), align_uint64(&tmp->bytes), tmp->timestamp);
+			break;
+		
+		default:
+			return;
+	}
+}
+
+static void
 table_list(uint16_t num, int need_header)
 {
 	ipfw_xtable *tbl;
 	ipfw_table_xentry *xent;
 	socklen_t l;
 	uint32_t *a, sz, tval;
+	char tval_buf[128];
+	char tmac_buf[128];
 	char tbuf[128];
 	struct in6_addr *addr6;
 	ip_fw3_opheader *op3;
@@ -4032,10 +4155,21 @@ table_list(uint16_t num, int need_header)
 
 			if (co.do_value_as_ip) {
 				tval = htonl(tval);
-				printf("%s/%u %s\n", tbuf, xent->masklen,
-				    inet_ntoa(*(struct in_addr *)&tval));
+				strlcpy(tval_buf, inet_ntoa(*(struct in_addr *)
+					&tval), sizeof(tval_buf));
 			} else
-				printf("%s/%u %u\n", tbuf, xent->masklen, tval);
+				snprintf(tval_buf, sizeof(tval_buf), "%u", tval);
+			
+			if (xent->mac_addr) {
+				uint8_t *x = (uint8_t *)&xent->mac_addr;
+				snprintf(tmac_buf, sizeof(tmac_buf), "mac %02x:%02x:%02x:%02x:%02x:%02x ",
+					x[0], x[1], x[2], x[3], x[4], x[5]);
+			} else {
+				tmac_buf[0] = 0;
+			}
+			
+			printf("%s/%u %s%s %llu %llu\n", tbuf, xent->masklen, tmac_buf, tval_buf, xent->packets, xent->bytes);
+		
 			break;
 		case IPFW_TABLE_INTERFACE:
 			/* Interface names */
diff --git a/sys/net/if_ethersubr.c b/sys/net/if_ethersubr.c
index 72f02fe..6c10211 100644
--- a/sys/net/if_ethersubr.c
+++ b/sys/net/if_ethersubr.c
@@ -143,7 +143,7 @@ MALLOC_DEFINE(M_ARPCOM, "arpcom", "802.* interface internals");
 
 #if defined(INET) || defined(INET6)
 int
-ether_ipfw_chk(struct mbuf **m0, struct ifnet *dst, int shared);
+ether_ipfw_chk(struct mbuf **m0, struct ifnet *dst, int shared, int dir);
 static VNET_DEFINE(int, ether_ipfw);
 #define	V_ether_ipfw	VNET(ether_ipfw)
 #endif
@@ -430,7 +430,7 @@ ether_output_frame(struct ifnet *ifp, struct mbuf *m)
 #if defined(INET) || defined(INET6)
 
 	if (V_ip_fw_chk_ptr && V_ether_ipfw != 0) {
-		if (ether_ipfw_chk(&m, ifp, 0) == 0) {
+		if (ether_ipfw_chk(&m, ifp, 0, DIR_OUT) == 0) {
 			if (m) {
 				m_freem(m);
 				return EACCES;	/* pkt dropped */
@@ -454,7 +454,7 @@ ether_output_frame(struct ifnet *ifp, struct mbuf *m)
  * ether_output_frame.
  */
 int
-ether_ipfw_chk(struct mbuf **m0, struct ifnet *dst, int shared)
+ether_ipfw_chk(struct mbuf **m0, struct ifnet *dst, int shared, int dir)
 {
 	struct ether_header *eh;
 	struct ether_header save_eh;
@@ -474,9 +474,11 @@ ether_ipfw_chk(struct mbuf **m0, struct ifnet *dst, int shared)
 		/* XXX can we free it after use ? */
 		mtag->m_tag_id = PACKET_TAG_NONE;
 		r = (struct ipfw_rule_ref *)(mtag + 1);
-		if (r->info & IPFW_ONEPASS)
+		//if (r->info & IPFW_ONEPASS) {
+			m_tag_delete(*m0, mtag);
 			return (1);
-		args.rule = *r;
+		//}
+		//args.rule = *r;
 	}
 
 	/*
@@ -501,6 +503,7 @@ ether_ipfw_chk(struct mbuf **m0, struct ifnet *dst, int shared)
 	args.next_hop = NULL;	/* we do not support forward yet	*/
 	args.eh = &save_eh;	/* MAC header for bridged/MAC packets	*/
 	args.inp = NULL;	/* used by ipfw uid/gid/jail rules	*/
+	args.dir = dir;		/* pfSense addition			*/
 	i = V_ip_fw_chk_ptr(&args);
 	m = args.m;
 	if (m != NULL) {
@@ -528,7 +531,7 @@ ether_ipfw_chk(struct mbuf **m0, struct ifnet *dst, int shared)
 		return 1;
 
 	if (ip_dn_io_ptr && (i == IP_FW_DUMMYNET)) {
-		int dir;
+		//int dir;
 		/*
 		 * Pass the pkt to dummynet, which consumes it.
 		 * If shared, make a copy and keep the original.
@@ -544,7 +547,7 @@ ether_ipfw_chk(struct mbuf **m0, struct ifnet *dst, int shared)
 			 */
 			*m0 = NULL ;
 		}
-		dir = PROTO_LAYER2 | (dst ? DIR_OUT : DIR_IN);
+		dir = PROTO_LAYER2 | dir;
 		ip_dn_io_ptr(&m, dir, &args);
 		return 0;
 	}
@@ -777,7 +780,7 @@ ether_demux(struct ifnet *ifp, struct mbuf *m)
 	 * Do not do this for PROMISC frames in case we are re-entered.
 	 */
 	if (V_ip_fw_chk_ptr && V_ether_ipfw != 0 && !(m->m_flags & M_PROMISC)) {
-		if (ether_ipfw_chk(&m, NULL, 0) == 0) {
+		if (ether_ipfw_chk(&m, ifp, 0, DIR_IN) == 0) {
 			if (m)
 				m_freem(m);	/* dropped; free mbuf chain */
 			return;			/* consumed */
@@ -820,7 +823,8 @@ ether_demux(struct ifnet *ifp, struct mbuf *m)
 	 * Strip off Ethernet header.
 	 */
 	m->m_flags &= ~M_VLANTAG;
-	m->m_flags &= ~(M_PROTOFLAGS);
+	if (!(m->m_flags & M_FASTFWD_OURS))
+		m->m_flags &= ~(M_PROTOFLAGS);
 	m_adj(m, ETHER_HDR_LEN);
 
 	/*
diff --git a/sys/netinet/ip_fw.h b/sys/netinet/ip_fw.h
index 69311a7..92e9579 100644
--- a/sys/netinet/ip_fw.h
+++ b/sys/netinet/ip_fw.h
@@ -74,6 +74,8 @@ typedef struct _ip_fw3_opheader {
 #define	IP_FW_TABLE_XDEL	87	/* delete entry */
 #define	IP_FW_TABLE_XGETSIZE	88	/* get table size */
 #define	IP_FW_TABLE_XLIST	89	/* list table contents */
+#define	IP_FW_TABLE_XZERO_ENTRY_STATS	90	/* reset stats */
+#define IP_FW_TABLE_XGET_ENTRY	91 /* get stats*/
 
 /*
  * The kernel representation of ipfw rules is made of a list of
@@ -588,9 +590,13 @@ struct _ipfw_dyn_rule {
 
 typedef struct	_ipfw_table_entry {
 	in_addr_t	addr;		/* network address		*/
+	u_int64_t	mac_addr;	/* mac address		*/
 	u_int32_t	value;		/* value			*/
 	u_int16_t	tbl;		/* table number			*/
 	u_int8_t	masklen;	/* mask length			*/
+	u_int64_t	bytes;
+	u_int64_t	packets;
+	u_int32_t	timestamp;
 } ipfw_table_entry;
 
 typedef struct	_ipfw_table_xentry {
@@ -598,12 +604,16 @@ typedef struct	_ipfw_table_xentry {
 	uint8_t		type;		/* entry type			*/
 	uint8_t		masklen;	/* mask length			*/
 	uint16_t	tbl;		/* table number			*/
+	u_int64_t	mac_addr;	/* mac address		*/
 	uint32_t	value;		/* value			*/
 	union {
 		/* Longest field needs to be aligned by 4-byte boundary	*/
 		struct in6_addr	addr6;	/* IPv6 address 		*/
 		char	iface[IF_NAMESIZE];	/* interface name	*/
 	} k;
+	u_int64_t	bytes;
+	u_int64_t	packets;
+	u_int32_t	timestamp;
 } ipfw_table_xentry;
 
 typedef struct	_ipfw_table {
diff --git a/sys/netinet/ipfw/ip_fw2.c b/sys/netinet/ipfw/ip_fw2.c
index 0d41564..53cb210 100644
--- a/sys/netinet/ipfw/ip_fw2.c
+++ b/sys/netinet/ipfw/ip_fw2.c
@@ -351,8 +351,8 @@ iface_match(struct ifnet *ifp, ipfw_insn_if *cmd, struct ip_fw_chain *chain, uin
 	/* Check by name or by IP address */
 	if (cmd->name[0] != '\0') { /* match by name */
 		if (cmd->name[0] == '\1') /* use tablearg to match */
-			return ipfw_lookup_table_extended(chain, cmd->p.glob,
-				ifp->if_xname, tablearg, IPFW_TABLE_INTERFACE);
+			return (ipfw_lookup_table_extended(chain, cmd->p.glob,
+				ifp->if_xname, NULL, tablearg, IPFW_TABLE_INTERFACE) == NULL) ? 0 : 1;
 		/* Check name */
 		if (cmd->p.glob) {
 			if (fnmatch(cmd->name, ifp->if_xname, 0) == 0)
@@ -890,6 +890,8 @@ ipfw_chk(struct ip_fw_args *args)
 	int dyn_dir = MATCH_UNKNOWN;
 	ipfw_dyn_rule *q = NULL;
 	struct ip_fw_chain *chain = &V_layer3_chain;
+	struct table_entry *tblent = NULL;
+	struct table_xentry *xtblent = NULL;
 
 	/*
 	 * We store in ulp a pointer to the upper layer protocol header.
@@ -1223,6 +1225,8 @@ do {								\
 			continue;
 
 		skip_or = 0;
+		tblent = NULL;
+		xtblent = NULL;
 		for (l = f->cmd_len, cmd = f->cmd ; l > 0 ;
 		    l -= cmdlen, cmd += cmdlen) {
 			int match;
@@ -1342,7 +1346,7 @@ do {								\
 				break;
 
 			case O_IN:	/* "out" is "not in" */
-				match = (oif == NULL);
+				match = (args->dir == DIR_IN);
 				break;
 
 			case O_LAYER2:
@@ -1378,11 +1382,17 @@ do {								\
 			case O_IP_SRC_LOOKUP:
 			case O_IP_DST_LOOKUP:
 				if (is_ipv4) {
+					struct ether_addr *ea = NULL;
 				    uint32_t key =
 					(cmd->opcode == O_IP_DST_LOOKUP) ?
 					    dst_ip.s_addr : src_ip.s_addr;
 				    uint32_t v = 0;
 
+					if (args->eh) {
+					ea = (struct ether_addr*)((cmd->opcode == O_IP_DST_LOOKUP) ?
+						args->eh->ether_dhost :
+						args->eh->ether_shost);
+				    }
 				    if (cmdlen > F_INSN_SIZE(ipfw_insn_u32)) {
 					/* generic lookup. The key must be
 					 * in 32bit big-endian format.
@@ -1427,22 +1437,38 @@ do {								\
 					} else
 					    break;
 				    }
-				    match = ipfw_lookup_table(chain,
-					cmd->arg1, key, &v);
-				    if (!match)
-					break;
+				    tblent = ipfw_lookup_table(chain,
+						cmd->arg1, key, ea, &v);
+				    if (tblent == NULL) {
+						match = 0;
+						break;
+				    } else
+						match = 1;
+
 				    if (cmdlen == F_INSN_SIZE(ipfw_insn_u32))
 					match =
 					    ((ipfw_insn_u32 *)cmd)->d[0] == v;
 				    else
 					tablearg = v;
 				} else if (is_ipv6) {
+					struct ether_addr *ea = NULL;
 					uint32_t v = 0;
+					
+					if (args->eh) {
+					ea = (struct ether_addr*)((cmd->opcode == O_IP_DST_LOOKUP) ?
+						args->eh->ether_dhost :
+						args->eh->ether_shost);
+				    }
 					void *pkey = (cmd->opcode == O_IP_DST_LOOKUP) ?
 						&args->f_id.dst_ip6: &args->f_id.src_ip6;
-					match = ipfw_lookup_table_extended(chain,
-							cmd->arg1, pkey, &v,
+					xtblent = ipfw_lookup_table_extended(chain,
+							cmd->arg1, pkey, ea, &v,
 							IPFW_TABLE_CIDR);
+					if (xtblent == NULL) {
+						match = 0;
+				    } else
+						match = 1;
+					
 					if (cmdlen == F_INSN_SIZE(ipfw_insn_u32))
 						match = ((ipfw_insn_u32 *)cmd)->d[0] == v;
 					if (match)
@@ -1722,7 +1748,7 @@ do {								\
 
 			case O_ANTISPOOF:
 				/* Outgoing packets automatically pass/match */
-				if (oif == NULL && hlen > 0 &&
+				if (args->dir == DIR_IN && hlen > 0 &&
 				    (  (is_ipv4 && in_localaddr(src_ip))
 #ifdef INET6
 				    || (is_ipv6 &&
@@ -2216,21 +2242,60 @@ do {								\
 				break;
 
 			case O_FORWARD_IP:
-				if (args->eh)	/* not valid on layer2 pkts */
-					break;
-				if (q == NULL || q->rule != f ||
-				    dyn_dir == MATCH_FORWARD) {
-				    struct sockaddr_in *sa;
-				    sa = &(((ipfw_insn_sa *)cmd)->sa);
-				    if (sa->sin_addr.s_addr == INADDR_ANY) {
-					bcopy(sa, &args->hopstore,
-							sizeof(*sa));
-					args->hopstore.sin_addr.s_addr =
-						    htonl(tablearg);
-					args->next_hop = &args->hopstore;
-				    } else {
-					args->next_hop = sa;
-				    }
+				if (!args->eh) {
+					if (q == NULL || q->rule != f ||
+						dyn_dir == MATCH_FORWARD) {
+						struct sockaddr_in *sa;
+						sa = &(((ipfw_insn_sa *)cmd)->sa);
+						if (sa->sin_addr.s_addr == INADDR_ANY) {
+							bcopy(sa, &args->hopstore, sizeof(*sa));
+							args->hopstore.sin_addr.s_addr = htonl(tablearg);
+							args->next_hop = &args->hopstore;
+						} else {
+						args->next_hop = sa;
+						}
+					}
+				} else if (args->eh) {
+					struct m_tag *fwd_tag;
+					struct sockaddr_in *sa;
+					u_short sum;
+
+					/*
+					 * Checksum correct? (from ip_fastfwd.c)
+					 */
+					if (m->m_pkthdr.csum_flags & CSUM_IP_CHECKED)
+						sum = !(m->m_pkthdr.csum_flags & CSUM_IP_VALID);
+					else {
+						if (hlen == sizeof(struct ip))
+							sum = in_cksum_hdr(ip);
+						else
+							sum = in_cksum(m, hlen);
+					}
+					if (sum) {
+						IPSTAT_INC(ips_badsum);
+						retval = IP_FW_DENY;
+						break;
+					}
+
+					/*
+					 * Remember that we have checked the IP header and found it valid.
+					 */
+					m->m_pkthdr.csum_flags |= (CSUM_IP_CHECKED | CSUM_IP_VALID);
+
+					sa = &(((ipfw_insn_sa *)cmd)->sa);
+					fwd_tag = m_tag_get(PACKET_TAG_IPFORWARD, sizeof(struct sockaddr_in), M_NOWAIT);
+					if (fwd_tag == NULL)
+						retval = IP_FW_DENY;
+					else {
+						bcopy(sa, (fwd_tag+1), sizeof(struct sockaddr_in));
+						m_tag_prepend(m, fwd_tag);
+ 
+						if (in_localip(sa->sin_addr)) {
+  							m->m_flags |= M_FASTFWD_OURS;
+							ip->ip_len = ntohs(ip->ip_len);
+							ip->ip_off = ntohs(ip->ip_off);
+						}
+					}
 				}
 				retval = IP_FW_PASS;
 				l = 0;          /* exit inner loop */
@@ -2378,6 +2443,15 @@ do {								\
 		rule->pcnt++;
 		rule->bcnt += pktlen;
 		rule->timestamp = time_uptime;
+		if (tblent != NULL) {
+			tblent->packets++;
+			tblent->bytes += pktlen;
+			tblent->timestamp = time_uptime;
+		} else if (xtblent != NULL) {
+			xtblent->packets++;
+			xtblent->bytes += pktlen;
+			xtblent->timestamp = time_uptime;
+		} 
 	} else {
 		retval = IP_FW_DENY;
 		printf("ipfw: ouch!, skip past end of rules, denying packet\n");
diff --git a/sys/netinet/ipfw/ip_fw_pfil.c b/sys/netinet/ipfw/ip_fw_pfil.c
index c2513c1..14dc018 100644
--- a/sys/netinet/ipfw/ip_fw_pfil.c
+++ b/sys/netinet/ipfw/ip_fw_pfil.c
@@ -131,7 +131,8 @@ again:
 	}
 
 	args.m = *m0;
-	args.oif = dir == DIR_OUT ? ifp : NULL;
+	args.oif = ifp;
+	args.dir = dir;
 	args.inp = inp;
 
 	ipfw = ipfw_chk(&args);
diff --git a/sys/netinet/ipfw/ip_fw_private.h b/sys/netinet/ipfw/ip_fw_private.h
index b91c154..95e31d2 100644
--- a/sys/netinet/ipfw/ip_fw_private.h
+++ b/sys/netinet/ipfw/ip_fw_private.h
@@ -34,6 +34,7 @@
  */
 
 #ifdef _KERNEL
+#include <net/radix.h>
 
 /*
  * For platforms that do not have SYSCTL support, we wrap the
@@ -61,6 +62,43 @@ enum {
 	IP_FW_REASS,
 };
 
+struct table_entry {
+        struct radix_node       rn[2];
+        struct sockaddr_in      addr, mask;
+        u_int64_t               mac_addr;
+        u_int32_t               value;
+        u_int64_t               bytes;
+        u_int64_t               packets;
+        u_int32_t               timestamp;
+};
+
+struct xaddr_iface {
+	uint8_t		if_len;		/* length of this struct */
+	uint8_t		pad[7];		/* Align name */
+	char 		ifname[IF_NAMESIZE];	/* Interface name */
+};
+
+struct table_xentry {
+	struct radix_node	rn[2];
+	union {
+#ifdef INET6
+		struct sockaddr_in6	addr6;
+#endif
+		struct xaddr_iface	iface;
+	} a;
+	union {
+#ifdef INET6
+		struct sockaddr_in6	mask6;
+#endif
+		struct xaddr_iface	ifmask;
+	} m;
+	u_int64_t               mac_addr;
+	u_int32_t		value;
+	u_int64_t               bytes;
+	u_int64_t               packets;
+	u_int32_t               timestamp;
+};
+
 /*
  * Structure for collecting parameters to dummynet for ip6_output forwarding
  */
@@ -96,6 +134,7 @@ struct ip_fw_args {
 	 */
 	struct ipfw_rule_ref rule;	/* match/restart info		*/
 
+	uint32_t dir;	/* direction */
 	struct ether_header *eh;	/* for bridged packets		*/
 
 	struct ipfw_flow_id f_id;	/* grabbed from IP header	*/
@@ -274,24 +313,36 @@ int ipfw_check_hook(void *arg, struct mbuf **m0, struct ifnet *ifp, int dir,
      struct inpcb *inp);
 
 /* In ip_fw_table.c */
-struct radix_node;
-int ipfw_lookup_table(struct ip_fw_chain *ch, uint16_t tbl, in_addr_t addr,
-    uint32_t *val);
-int ipfw_lookup_table_extended(struct ip_fw_chain *ch, uint16_t tbl, void *paddr,
-    uint32_t *val, int type);
+struct ether_addr;
+//struct radix_node;
+struct table_entry * ipfw_lookup_table(struct ip_fw_chain *ch, uint16_t tbl, in_addr_t addr,
+    struct ether_addr *ea, uint32_t *val);
+struct table_xentry * ipfw_lookup_table_extended(struct ip_fw_chain *ch, uint16_t tbl, void *paddr,
+    struct ether_addr *ea, uint32_t *val, int type);
+
 int ipfw_init_tables(struct ip_fw_chain *ch);
 void ipfw_destroy_tables(struct ip_fw_chain *ch);
-int ipfw_flush_table(struct ip_fw_chain *ch, uint16_t tbl);
+int ipfw_resize_tables(struct ip_fw_chain *ch, unsigned int ntables);
+
 int ipfw_add_table_entry(struct ip_fw_chain *ch, uint16_t tbl, void *paddr,
-    uint8_t plen, uint8_t mlen, uint8_t type, uint32_t value);
+    uint8_t plen, uint8_t mlen, u_int64_t mac_addr, uint8_t type, uint32_t value);
 int ipfw_del_table_entry(struct ip_fw_chain *ch, uint16_t tbl, void *paddr,
     uint8_t plen, uint8_t mlen, uint8_t type);
+
+int ipfw_flush_table(struct ip_fw_chain *ch, uint16_t tbl);
+int ipfw_flush_table_entry(struct radix_node *rn, void *arg);
 int ipfw_count_table(struct ip_fw_chain *ch, uint32_t tbl, uint32_t *cnt);
-int ipfw_dump_table_entry(struct radix_node *rn, void *arg);
-int ipfw_dump_table(struct ip_fw_chain *ch, ipfw_table *tbl);
 int ipfw_count_xtable(struct ip_fw_chain *ch, uint32_t tbl, uint32_t *cnt);
+int ipfw_count_table_entry(struct radix_node *rn, void *arg);
+int ipfw_count_table_xentry(struct radix_node *rn, void *arg);
+int ipfw_dump_table(struct ip_fw_chain *ch, ipfw_table *tbl);
 int ipfw_dump_xtable(struct ip_fw_chain *ch, ipfw_xtable *tbl);
-int ipfw_resize_tables(struct ip_fw_chain *ch, unsigned int ntables);
+int ipfw_dump_table_entry(struct radix_node *rn, void *arg);
+int ipfw_dump_table_xentry_base(struct radix_node *rn, void *arg);
+int ipfw_dump_table_xentry_extended(struct radix_node *rn, void *arg);
+
+int ipfw_zero_table_entry_stats(struct ip_fw_chain *ch, uint16_t tbl, void *paddr,
+    uint8_t plen, uint8_t mlen, uint8_t type);
 
 /* In ip_fw_nat.c -- XXX to be moved to ip_var.h */
 
diff --git a/sys/netinet/ipfw/ip_fw_sockopt.c b/sys/netinet/ipfw/ip_fw_sockopt.c
index 52180a0..72f26c0 100644
--- a/sys/netinet/ipfw/ip_fw_sockopt.c
+++ b/sys/netinet/ipfw/ip_fw_sockopt.c
@@ -1116,7 +1116,7 @@ ipfw_ctl(struct sockopt *sopt)
 			if (error)
 				break;
 			error = ipfw_add_table_entry(chain, ent.tbl,
-			    &ent.addr, sizeof(ent.addr), ent.masklen, 
+			    &ent.addr, sizeof(ent.addr), ent.masklen, ent.mac_addr,
 			    IPFW_TABLE_CIDR, ent.value);
 		}
 		break;
@@ -1155,7 +1155,7 @@ ipfw_ctl(struct sockopt *sopt)
 
 			error = (opt == IP_FW_TABLE_XADD) ?
 				ipfw_add_table_entry(chain, xent->tbl, &xent->k, 
-					len, xent->masklen, xent->type, xent->value) :
+					len, xent->masklen, xent->mac_addr, xent->type, xent->value) :
 				ipfw_del_table_entry(chain, xent->tbl, &xent->k,
 					len, xent->masklen, xent->type);
 		}
@@ -1189,6 +1189,114 @@ ipfw_ctl(struct sockopt *sopt)
 		}
 		break;
 
+	case IP_FW_TABLE_XGET_ENTRY: /* IP_FW3 */
+		{
+			ipfw_table_xentry *xent;
+			ip_fw3_opheader *tmpop3;
+			time_t boot_seconds;
+			
+			/* Check minimum header size */
+			if (IP_FW3_OPLENGTH(sopt) < offsetof(ipfw_table_xentry, k)) {
+				error = EINVAL;
+				break;
+			}
+			
+			tmpop3 = malloc(valsize, M_TEMP, M_ZERO | M_WAITOK);
+			memcpy(tmpop3, op3, valsize);
+			xent = (ipfw_table_xentry *)(tmpop3 + 1);
+			len = xent->len - offsetof(ipfw_table_xentry, k);
+			boot_seconds = boottime.tv_sec;
+			
+			IPFW_RLOCK(chain);
+			switch (xent->type) {
+				case IPFW_TABLE_CIDR:
+					if (len == sizeof(in_addr_t)) {
+						/* IPv4 address */
+						struct table_entry *tblent = ipfw_lookup_table(chain, xent->tbl, 
+							*((in_addr_t *)&xent->k), NULL, &xent->value);
+						
+						if (tblent != NULL) {
+							xent->bytes = tblent->bytes;
+							xent->packets = tblent->packets;
+							xent->timestamp = tblent->timestamp + boot_seconds;
+						} else 
+							error = EINVAL;
+#ifdef INET6
+					} else if (len == sizeof(struct in6_addr)) {
+						/* IPv6 address */
+						struct table_xentry *xtblent = ipfw_lookup_table_extended(chain, xent->tbl, 
+							&xent->k.addr6, NULL, &xent->value, IPFW_TABLE_CIDR);
+						
+						if (xtblent != NULL) {
+							xent->bytes = xtblent->bytes;
+							xent->packets = xtblent->packets;
+							xent->timestamp = xtblent->timestamp + boot_seconds;
+						} else 
+							error = EINVAL;
+#endif
+					} else {
+						/* Unknown CIDR type */
+						error = EINVAL;
+					}
+					break;
+				
+				case IPFW_TABLE_INTERFACE:
+				{
+					struct table_xentry *xtblent = ipfw_lookup_table_extended(chain, xent->tbl, 
+						(struct sockaddr *)&xent->k.iface, NULL, &xent->value, IPFW_TABLE_INTERFACE);
+					
+					if (xtblent != NULL) {
+						xent->bytes = xtblent->bytes;
+						xent->packets = xtblent->packets;
+						xent->timestamp = xtblent->timestamp + boot_seconds;
+					} else 
+						error = EINVAL;
+					break;
+				}
+
+				default:
+					error = EINVAL;
+				}
+			IPFW_RUNLOCK(chain);
+			
+			if (error) {
+				free(tmpop3, M_TEMP);
+				break;
+			}
+			
+			/* 
+			 * Since we call sooptcopyin() with small buffer, sopt_valsize is
+			 * decreased to reflect supplied buffer size. Set it back to original value
+			 */
+			sopt->sopt_valsize = valsize;
+			error = sooptcopyout(sopt, tmpop3, valsize);
+			free(tmpop3, M_TEMP);
+		}
+		break;
+
+	case IP_FW_TABLE_XZERO_ENTRY_STATS: /* IP_FW3 */
+		{
+			ipfw_table_xentry *xent = (ipfw_table_xentry *)(op3 + 1);
+
+			/* Check minimum header size */
+			if (IP_FW3_OPLENGTH(sopt) < offsetof(ipfw_table_xentry, k)) {
+				error = EINVAL;
+				break;
+			}
+
+			/* Check if len field is valid */
+			if (xent->len > sizeof(ipfw_table_xentry)) {
+				error = EINVAL;
+				break;
+			}
+			
+			len = xent->len - offsetof(ipfw_table_xentry, k);
+
+			error = ipfw_zero_table_entry_stats(chain, xent->tbl, &xent->k,
+					len, xent->masklen, xent->type);
+		}
+		break;
+
 	case IP_FW_TABLE_LIST:
 		{
 			ipfw_table *tbl;
diff --git a/sys/netinet/ipfw/ip_fw_table.c b/sys/netinet/ipfw/ip_fw_table.c
index 764b413..d388d49 100644
--- a/sys/netinet/ipfw/ip_fw_table.c
+++ b/sys/netinet/ipfw/ip_fw_table.c
@@ -60,6 +60,7 @@ __FBSDID("$FreeBSD$");
 
 #include <netinet/in.h>
 #include <netinet/ip_var.h>	/* struct ipfw_rule_ref */
+#include <net/ethernet.h>       /* struct ether_addr */
 #include <netinet/ip_fw.h>
 #include <sys/queue.h> /* LIST_HEAD */
 #include <netinet/ipfw/ip_fw_private.h>
@@ -70,18 +71,27 @@ __FBSDID("$FreeBSD$");
 
 MALLOC_DEFINE(M_IPFW_TBL, "ipfw_tbl", "IpFw tables");
 
+#if 0
 struct table_entry {
 	struct radix_node	rn[2];
 	struct sockaddr_in	addr, mask;
+	u_int64_t		mac_addr;
 	u_int32_t		value;
+	u_int64_t		bytes;
+	u_int64_t		packets;
+	u_int32_t		timestamp;
 };
+#endif
 
+#if 0
 struct xaddr_iface {
 	uint8_t		if_len;		/* length of this struct */
 	uint8_t		pad[7];		/* Align name */
 	char 		ifname[IF_NAMESIZE];	/* Interface name */
 };
+#endif
 
+#if 0
 struct table_xentry {
 	struct radix_node	rn[2];
 	union {
@@ -96,8 +106,13 @@ struct table_xentry {
 #endif
 		struct xaddr_iface	ifmask;
 	} m;
+	u_int64_t		mac_addr;
 	u_int32_t		value;
+	u_int64_t		bytes;
+	u_int64_t		packets;
+	u_int32_t		timestamp;
 };
+#endif
 
 /*
  * The radix code expects addr and mask to be array of bytes,
@@ -134,7 +149,7 @@ ipv6_writemask(struct in6_addr *addr6, uint8_t mask)
 
 int
 ipfw_add_table_entry(struct ip_fw_chain *ch, uint16_t tbl, void *paddr,
-    uint8_t plen, uint8_t mlen, uint8_t type, uint32_t value)
+    uint8_t plen, uint8_t mlen, u_int64_t mac_addr, uint8_t type, uint32_t value)
 {
 	struct radix_node_head *rnh, **rnh_ptr;
 	struct table_entry *ent;
@@ -163,6 +178,7 @@ ipfw_add_table_entry(struct ip_fw_chain *ch, uint16_t tbl, void *paddr,
 			ent->mask.sin_addr.s_addr = htonl(mlen ? ~((1 << (32 - mlen)) - 1) : 0);
 			addr = *((in_addr_t *)paddr);
 			ent->addr.sin_addr.s_addr = addr & ent->mask.sin_addr.s_addr;
+			ent->mac_addr = mac_addr;
 			/* Set pointers */
 			rnh_ptr = &ch->tables[tbl];
 			ent_ptr = ent;
@@ -184,6 +200,7 @@ ipfw_add_table_entry(struct ip_fw_chain *ch, uint16_t tbl, void *paddr,
 			ipv6_writemask(&xent->m.mask6.sin6_addr, mlen);
 			memcpy(&xent->a.addr6.sin6_addr, paddr, sizeof(struct in6_addr));
 			APPLY_MASK(&xent->a.addr6.sin6_addr, &xent->m.mask6.sin6_addr);
+			xent->mac_addr = mac_addr;
 			/* Set pointers */
 			rnh_ptr = &ch->xtables[tbl];
 			ent_ptr = xent;
@@ -383,8 +400,8 @@ ipfw_del_table_entry(struct ip_fw_chain *ch, uint16_t tbl, void *paddr,
 	return (0);
 }
 
-static int
-flush_table_entry(struct radix_node *rn, void *arg)
+int
+ipfw_flush_table_entry(struct radix_node *rn, void *arg)
 {
 	struct radix_node_head * const rnh = arg;
 	struct table_entry *ent;
@@ -422,12 +439,12 @@ ipfw_flush_table(struct ip_fw_chain *ch, uint16_t tbl)
 	IPFW_WUNLOCK(ch);
 
 	if (rnh != NULL) {
-		rnh->rnh_walktree(rnh, flush_table_entry, rnh);
+		rnh->rnh_walktree(rnh, ipfw_flush_table_entry, rnh);
 		rn_detachhead((void **)&rnh);
 	}
 
 	if (xrnh != NULL) {
-		xrnh->rnh_walktree(xrnh, flush_table_entry, xrnh);
+		xrnh->rnh_walktree(xrnh, ipfw_flush_table_entry, xrnh);
 		rn_detachhead((void **)&xrnh);
 	}
 
@@ -502,12 +519,12 @@ ipfw_resize_tables(struct ip_fw_chain *ch, unsigned int ntables)
 	if (ntables < ntables_old) {
 		for (tbl = ntables; tbl < ntables_old; tbl++) {
 			if ((rnh = tables_old[tbl]) != NULL) {
-				rnh->rnh_walktree(rnh, flush_table_entry, rnh);
+				rnh->rnh_walktree(rnh, ipfw_flush_table_entry, rnh);
 				rn_detachhead((void **)&rnh);
 			}
 
 			if ((rnh = xtables_old[tbl]) != NULL) {
-				rnh->rnh_walktree(rnh, flush_table_entry, rnh);
+				rnh->rnh_walktree(rnh, ipfw_flush_table_entry, rnh);
 				rn_detachhead((void **)&rnh);
 			}
 		}
@@ -521,31 +538,36 @@ ipfw_resize_tables(struct ip_fw_chain *ch, unsigned int ntables)
 	return (0);
 }
 
-int
+struct table_entry *
 ipfw_lookup_table(struct ip_fw_chain *ch, uint16_t tbl, in_addr_t addr,
-    uint32_t *val)
+    struct ether_addr *ea, uint32_t *val)
 {
 	struct radix_node_head *rnh;
 	struct table_entry *ent;
 	struct sockaddr_in sa;
 
 	if (tbl >= V_fw_tables_max)
-		return (0);
+		return (NULL);
 	if ((rnh = ch->tables[tbl]) == NULL)
-		return (0);
+		return (NULL);
 	KEY_LEN(sa) = KEY_LEN_INET;
 	sa.sin_addr.s_addr = addr;
 	ent = (struct table_entry *)(rnh->rnh_lookup(&sa, NULL, rnh));
 	if (ent != NULL) {
+		if (ea && ent->mac_addr) {
+			u_char *test = (u_char *)&ent->mac_addr;
+			if (bcmp(test, ea->octet, ETHER_ADDR_LEN) != 0)
+				return (NULL);
+		}
 		*val = ent->value;
-		return (1);
+		return (ent);
 	}
-	return (0);
+	return (NULL);
 }
 
-int
+struct table_xentry *
 ipfw_lookup_table_extended(struct ip_fw_chain *ch, uint16_t tbl, void *paddr,
-    uint32_t *val, int type)
+    struct ether_addr *ea, uint32_t *val, int type)
 {
 	struct radix_node_head *rnh;
 	struct table_xentry *xent;
@@ -553,9 +575,9 @@ ipfw_lookup_table_extended(struct ip_fw_chain *ch, uint16_t tbl, void *paddr,
 	struct xaddr_iface iface;
 
 	if (tbl >= V_fw_tables_max)
-		return (0);
+		return (NULL);
 	if ((rnh = ch->xtables[tbl]) == NULL)
-		return (0);
+		return (NULL);
 
 	switch (type) {
 	case IPFW_TABLE_CIDR:
@@ -572,18 +594,116 @@ ipfw_lookup_table_extended(struct ip_fw_chain *ch, uint16_t tbl, void *paddr,
 		break;
 
 	default:
-		return (0);
+		return (NULL);
 	}
 
 	if (xent != NULL) {
+		if (ea && xent->mac_addr) {
+			u_char *test = (u_char *)&xent->mac_addr;
+			if (bcmp(test, ea->octet, ETHER_ADDR_LEN) != 0)
+				return (NULL);
+		}
 		*val = xent->value;
-		return (1);
+		return (xent);
 	}
-	return (0);
+	return (NULL);
+}
+
+int
+ipfw_zero_table_entry_stats(struct ip_fw_chain *ch, uint16_t tbl, void *paddr,
+    uint8_t plen, uint8_t mlen, uint8_t type)
+{
+	struct radix_node_head *rnh, **rnh_ptr;
+	struct sockaddr *sa_ptr;
+
+	if (tbl >= V_fw_tables_max)
+		return (EINVAL);
+
+	switch (type) {
+	case IPFW_TABLE_CIDR:
+		if (plen == sizeof(in_addr_t)) {
+			in_addr_t addr;
+			/* IPv4 case */
+			struct sockaddr_in sa;
+			/* Set 'total' structure length */
+			KEY_LEN(sa) = KEY_LEN_INET;
+			addr = *((in_addr_t *)paddr);
+			sa.sin_addr.s_addr = addr;
+			rnh_ptr = &ch->tables[tbl];
+			sa_ptr = (struct sockaddr *)&sa;
+#ifdef INET6
+		} else if (plen == sizeof(struct in6_addr)) {
+			/* IPv6 case */
+			struct sockaddr_in6 sa6;
+			memset(&sa6, 0, sizeof(struct sockaddr_in6));
+			/* Set 'total' structure length */
+			KEY_LEN(sa6) = KEY_LEN_INET6;
+			memcpy(&sa6.sin6_addr, paddr, sizeof(struct in6_addr));
+			rnh_ptr = &ch->xtables[tbl];
+			sa_ptr = (struct sockaddr *)&sa6;
+#endif
+		} else {
+			/* Unknown CIDR type */
+			return (EINVAL);
+		}
+		break;
+
+	case IPFW_TABLE_INTERFACE:
+		{
+		struct xaddr_iface iface;
+		/* Assume direct match */
+		/* FIXME: Add interface pattern matching */
+		KEY_LEN(iface) = strlcpy(iface.ifname, (char *)paddr, IF_NAMESIZE);
+		/* Set pointers */
+		rnh_ptr = &ch->xtables[tbl];
+		sa_ptr = (struct sockaddr *)&iface;
+		}
+		break;
+
+	default:
+		return (EINVAL);
+	}
+
+	IPFW_WLOCK(ch);
+	if ((rnh = *rnh_ptr) == NULL) {
+		IPFW_WUNLOCK(ch);
+		return (ESRCH);
+	}
+
+	if (ch->tabletype[tbl] != type) {
+		IPFW_WUNLOCK(ch);
+		return (EINVAL);
+	}
+
+	if (plen == sizeof(in_addr_t)) {
+		struct table_entry *ent;
+		ent = (struct table_entry *)rnh->rnh_lookup(sa_ptr, NULL, rnh);
+		
+		if (ent != NULL) {
+			ent->packets = 0;
+			ent->bytes = 0;
+			ent->timestamp = time_uptime;
+			IPFW_WUNLOCK(ch);
+			return (0);
+		}
+	} else if (plen == sizeof(struct in6_addr)) {
+		struct table_xentry *xent;
+		xent = (struct table_xentry *)rnh->rnh_lookup(sa_ptr, NULL, rnh);
+		if (xent != NULL) {
+			xent->packets = 0;
+			xent->bytes = 0;
+			xent->timestamp = time_uptime;
+			IPFW_WUNLOCK(ch);
+			return (0);
+		}
+	}
+	
+	IPFW_WUNLOCK(ch);
+	return (EINVAL);
 }
 
-static int
-count_table_entry(struct radix_node *rn, void *arg)
+int
+ipfw_count_table_entry(struct radix_node *rn, void *arg)
 {
 	u_int32_t * const cnt = arg;
 
@@ -601,12 +721,12 @@ ipfw_count_table(struct ip_fw_chain *ch, uint32_t tbl, uint32_t *cnt)
 	*cnt = 0;
 	if ((rnh = ch->tables[tbl]) == NULL)
 		return (0);
-	rnh->rnh_walktree(rnh, count_table_entry, cnt);
+	rnh->rnh_walktree(rnh, ipfw_count_table_entry, cnt);
 	return (0);
 }
 
-static int
-dump_table_entry(struct radix_node *rn, void *arg)
+int
+ipfw_dump_table_entry(struct radix_node *rn, void *arg)
 {
 	struct table_entry * const n = (struct table_entry *)rn;
 	ipfw_table * const tbl = arg;
@@ -622,6 +742,9 @@ dump_table_entry(struct radix_node *rn, void *arg)
 		ent->masklen = 33 - ffs(ntohl(n->mask.sin_addr.s_addr));
 	ent->addr = n->addr.sin_addr.s_addr;
 	ent->value = n->value;
+	ent->mac_addr = n->mac_addr;
+	ent->packets = n->packets;
+	ent->bytes = n->bytes;
 	tbl->cnt++;
 	return (0);
 }
@@ -636,12 +759,12 @@ ipfw_dump_table(struct ip_fw_chain *ch, ipfw_table *tbl)
 	tbl->cnt = 0;
 	if ((rnh = ch->tables[tbl->tbl]) == NULL)
 		return (0);
-	rnh->rnh_walktree(rnh, dump_table_entry, tbl);
+	rnh->rnh_walktree(rnh, ipfw_dump_table_entry, tbl);
 	return (0);
 }
 
-static int
-count_table_xentry(struct radix_node *rn, void *arg)
+int
+ipfw_count_table_xentry(struct radix_node *rn, void *arg)
 {
 	uint32_t * const cnt = arg;
 
@@ -658,9 +781,9 @@ ipfw_count_xtable(struct ip_fw_chain *ch, uint32_t tbl, uint32_t *cnt)
 		return (EINVAL);
 	*cnt = 0;
 	if ((rnh = ch->tables[tbl]) != NULL)
-		rnh->rnh_walktree(rnh, count_table_xentry, cnt);
+		rnh->rnh_walktree(rnh, ipfw_count_table_xentry, cnt);
 	if ((rnh = ch->xtables[tbl]) != NULL)
-		rnh->rnh_walktree(rnh, count_table_xentry, cnt);
+		rnh->rnh_walktree(rnh, ipfw_count_table_xentry, cnt);
 	/* Return zero if table is empty */
 	if (*cnt > 0)
 		(*cnt) += sizeof(ipfw_xtable);
@@ -668,8 +791,8 @@ ipfw_count_xtable(struct ip_fw_chain *ch, uint32_t tbl, uint32_t *cnt)
 }
 
 
-static int
-dump_table_xentry_base(struct radix_node *rn, void *arg)
+int
+ipfw_dump_table_xentry_base(struct radix_node *rn, void *arg)
 {
 	struct table_entry * const n = (struct table_entry *)rn;
 	ipfw_xtable * const tbl = arg;
@@ -688,12 +811,15 @@ dump_table_xentry_base(struct radix_node *rn, void *arg)
 	/* Save IPv4 address as deprecated IPv6 compatible */
 	xent->k.addr6.s6_addr32[3] = n->addr.sin_addr.s_addr;
 	xent->value = n->value;
+	xent->mac_addr = n->mac_addr;
+	xent->packets = n->packets;
+	xent->bytes = n->bytes;
 	tbl->cnt++;
 	return (0);
 }
 
-static int
-dump_table_xentry_extended(struct radix_node *rn, void *arg)
+int
+ipfw_dump_table_xentry_extended(struct radix_node *rn, void *arg)
 {
 	struct table_xentry * const n = (struct table_xentry *)rn;
 	ipfw_xtable * const tbl = arg;
@@ -731,6 +857,9 @@ dump_table_xentry_extended(struct radix_node *rn, void *arg)
 	}
 
 	xent->value = n->value;
+	xent->mac_addr = n->mac_addr;
+	xent->packets = n->packets;
+	xent->bytes = n->bytes;
 	tbl->cnt++;
 	return (0);
 }
@@ -745,9 +874,9 @@ ipfw_dump_xtable(struct ip_fw_chain *ch, ipfw_xtable *tbl)
 	tbl->cnt = 0;
 	tbl->type = ch->tabletype[tbl->tbl];
 	if ((rnh = ch->tables[tbl->tbl]) != NULL)
-		rnh->rnh_walktree(rnh, dump_table_xentry_base, tbl);
+		rnh->rnh_walktree(rnh, ipfw_dump_table_xentry_base, tbl);
 	if ((rnh = ch->xtables[tbl->tbl]) != NULL)
-		rnh->rnh_walktree(rnh, dump_table_xentry_extended, tbl);
+		rnh->rnh_walktree(rnh, ipfw_dump_table_xentry_extended, tbl);
 	return (0);
 }
 
